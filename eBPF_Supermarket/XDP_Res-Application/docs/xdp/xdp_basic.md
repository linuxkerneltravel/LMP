## XDP基本原理

XDP 可在最早可以处理包的位置（即网卡驱动收到包的时刻）运行 BPF程序，并且暴露了一个可以加载 BPF 程序的网络钩子。在这个钩子中，程序能够对传入的数据包进行判别修改并快速决策，避免了内核内部处理带来的额外开销。如图 1 所示，通常 XDP 有以下三种工作方式：
<img src="./images/xdpmode.png" />
图 1 XDP 的三种工作方式

- offload：XDP 程序直接加载到 NIC 上，并且不使用 CPU 执行。这需要网络接口设备的支持。
- native：XDP 程序由网卡驱动程序加载，作为其初始接收路径的一部分。这也需要网卡驱动的支持。
- generic：XDP 程序作为普通网络路径的一部分加载到内核中。

这三种方式中，offload 的性能最好，但它需要网络设备的支持，所以不具备普遍的兼容性。generic 的兼容性最好，无需特殊的网络设备或驱动支持，但其性能最弱。native 介于二者之间，其在驱动层运行，在性能和兼容性上比较平衡。（考虑到后期可能需要移植到搭载鸿蒙系统的设备上，计划先在 generic上将程序跑通，再逐步向 native 上迁移）

XDP 程序运行在内核网络协议栈之前，一个数据包经过网络协议栈的处理会产生相当大的开销，所以 XDP 提供了几种基本的能力，包括：

- XDP_DROP
丢弃且不处理数据包。eBPF 程序可以分析流量模式并使用过滤器实时更新 XDP 应用程序以丢弃特定类型的数据包（例如，恶意流量）。
- XDP_PASS
指示应将数据包转发到正常网络堆栈以进行进一步处理。XDP 程序可以在此之前修改包的内容。
- XDP_TX
将数据包（可能已被修改）转发到接收它的同一网络接口。
- XDP_REDIRECT
绕过正常的网络堆栈并通过另一个 NIC 将数据包重定向到网络。

一个典型的 XDP 程序执行流如图 2 所示，包括四个步骤：

<img src="./images/process.png" />
图 2 典型的 XDP 程序执行流

第一步是解析 packet，比如解析出 IP 地址、MAC 地址、使用的协议、访问的端口等。第二步是读（写）元信息，例如从哪个网卡的哪个接口收上来的（ifindex）或者利用 helpers 辅助函数结合 BPF Map 更新统计信息。第三步是在有某些特殊需求的时候重写 packet。第四步是对这个 packet 做一个判决，如上述丢包、转发、重定向等。